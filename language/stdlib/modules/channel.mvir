// The module for the channel resource
module Channel {
    import 0x0.LibraAccount;
    import 0x0.LibraCoin;
    import 0x00.Hash;
    import 0x0.U64Util;
    import 0x0.AddressUtil;
    import 0x0.BytearrayUtil;
    import 0x0.Vector;
    import 0x0.ChannelTransaction;

    resource T {
        channel_sequence_number: u64,
        closed: bool,
        locked: bool,
        participants: Vector.T<address>,
    }

    resource ChannelAccount {
        balance: LibraCoin.T,
    }

    //TODO native
    // sort participants and generate address;
//    generate_channel_address(participants: &mut Vector.T<address>): address{
//        return 0x1;
//    }
    native generate_channel_address(participant_1: address, participant_2: address): address;
    //TODO native
    native save_channel(channel_address: address, channel: Self.T);

    //TODO native
    native init_participant(channel_address: address, participant:address, participant_account: Self.ChannelAccount);

    native move_to_channel<R:resource>(r: R);

    //only support one participant
    public open(participant: address, signature: bytearray, amount: u64){
        let channel_address: address;
        let participants: Vector.T<address>;
        let sender: address;
        let channel: Self.T;
        let sender_account: Self.ChannelAccount;
        let participant_account: Self.ChannelAccount;
        let participant_1: address;
        let participant_2: address;

        sender = get_txn_sender();
        //TODO check participant_signature

        participants = Vector.empty<address>();
        Vector.push_back<address>(
             &mut participants,
             copy(sender)
        );
        Vector.push_back<address>(
             &mut participants,
             copy(participant)
        );

        participant_1 = Vector.get<address>(&participants, 0);
        participant_2 = Vector.get<address>(&participants, 1);
        channel_address = Self.generate_channel_address(move(participant_1), move(participant_2));
        LibraAccount.create_account(copy(channel_address));
        channel = T {
           channel_sequence_number: 0,
           closed: false,
           locked: false,
           participants: move(participants),
        };
        sender_account = ChannelAccount{
            balance: LibraAccount.withdraw_from_sender(move(amount)),
        };
        participant_account = ChannelAccount{
            balance: LibraCoin.zero(),
        };
        Self.save_channel(copy(channel_address),move(channel));
        Self.init_participant(copy(channel_address), move(sender), move(sender_account));
        Self.init_participant(move(channel_address), move(participant), move(participant_account));
        return;
    }

    //public native move_to_participant<T>(participant: address, t: T);

    //public native move_to_shared<T>(t: T);

    //public native move_from_participant<T>(participant: address): T;

    //public native move_from_shared<T>(): T;

    //public native borrow_from_participant<T>(participant: address): & T;

    //public native borrow_from_participant_mut<T>(participant: address): &mut T;

    //public native borrow_from_shared<T>(): & T;

    //public native borrow_from_shared_mut<T>(participant: address): &mut T;

}
